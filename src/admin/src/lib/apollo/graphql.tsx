export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Cursor: { input: any; output: any; }
  DateOnly: { input: any; output: any; }
  DateTime: { input: any; output: any; }
  Time: { input: any; output: any; }
  TimeOnly: { input: any; output: any; }
};

export type CreateManyPermissionInput = {
  connect?: InputMaybe<Array<PermissionWhereUniqueInput>>;
  create?: InputMaybe<Array<CreatePermissionInput>>;
};

export type CreateManyRoleInput = {
  connect?: InputMaybe<Array<RoleWhereUniqueInput>>;
  create?: InputMaybe<Array<CreateRoleInput>>;
};

export type CreateManyUserInput = {
  connect?: InputMaybe<Array<UserWhereUniqueInput>>;
  create?: InputMaybe<Array<CreateUserInput>>;
};

export type CreateOnePermissionInput = {
  connect?: InputMaybe<PermissionWhereUniqueInput>;
  create?: InputMaybe<CreatePermissionInput>;
};

export type CreateOneRoleInput = {
  connect?: InputMaybe<RoleWhereUniqueInput>;
  create?: InputMaybe<CreateRoleInput>;
};

export type CreateOneUserInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  create?: InputMaybe<CreateUserInput>;
};

/**
 * CreatePermissionInput is used for create Permission object.
 * Input was generated by ent.
 */
export type CreatePermissionInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdBy?: InputMaybe<CreateOneUserInput>;
  createdByID?: InputMaybe<Scalars['ID']['input']>;
  entity: Scalars['String']['input'];
  operation?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<CreateOneRoleInput>;
  roleID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
  updatedByID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateRoleInput is used for create Role object.
 * Input was generated by ent.
 */
export type CreateRoleInput = {
  createdBy?: InputMaybe<CreateOneUserInput>;
  name: Scalars['String']['input'];
  permissions?: InputMaybe<CreateManyPermissionInput>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
  userRoles?: InputMaybe<CreateManyUserInput>;
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  createdBy?: InputMaybe<CreateOneUserInput>;
  defaultRole?: InputMaybe<CreateOneRoleInput>;
  defaultRoleID?: InputMaybe<Scalars['ID']['input']>;
  email: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  password: Scalars['String']['input'];
  refCreatedBy?: InputMaybe<CreateManyUserInput>;
  refUpdatedBy?: InputMaybe<CreateManyUserInput>;
  roleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  roles?: InputMaybe<CreateManyRoleInput>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createManyPermissions: Array<Maybe<Permission>>;
  createManyRoles: Array<Maybe<Role>>;
  createManyUsers: Array<Maybe<User>>;
  createPermission: Permission;
  createRole: Role;
  createUser: User;
  deleteManyPermissions: Scalars['Int']['output'];
  deleteManyRoles: Scalars['Int']['output'];
  deleteManyUsers: Scalars['Int']['output'];
  deletePermission: Permission;
  deleteRole: Role;
  deleteUser: User;
  updateManyPermissions: Scalars['Int']['output'];
  updateManyRoles: Scalars['Int']['output'];
  updateManyUsers: Scalars['Int']['output'];
  updatePermission: Permission;
  updateRole: Role;
  updateUser: User;
  upsertManyPermissions: Scalars['Int']['output'];
  upsertManyRoles: Scalars['Int']['output'];
  upsertManyUsers: Scalars['Int']['output'];
  upsertPermission: Permission;
  upsertRole: Role;
  upsertUser: User;
};


export type MutationCreateManyPermissionsArgs = {
  data: Array<CreatePermissionInput>;
};


export type MutationCreateManyRolesArgs = {
  data: Array<CreateRoleInput>;
};


export type MutationCreateManyUsersArgs = {
  data: Array<CreateUserInput>;
};


export type MutationCreatePermissionArgs = {
  data: CreatePermissionInput;
};


export type MutationCreateRoleArgs = {
  data: CreateRoleInput;
};


export type MutationCreateUserArgs = {
  data: CreateUserInput;
};


export type MutationDeleteManyPermissionsArgs = {
  where: PermissionWhereInput;
};


export type MutationDeleteManyRolesArgs = {
  where: RoleWhereInput;
};


export type MutationDeleteManyUsersArgs = {
  where: UserWhereInput;
};


export type MutationDeletePermissionArgs = {
  where: PermissionWhereUniqueInput;
};


export type MutationDeleteRoleArgs = {
  where: RoleWhereUniqueInput;
};


export type MutationDeleteUserArgs = {
  where: UserWhereUniqueInput;
};


export type MutationUpdateManyPermissionsArgs = {
  data: UpdatePermissionInput;
  where: PermissionWhereInput;
};


export type MutationUpdateManyRolesArgs = {
  data: UpdateRoleInput;
  where: RoleWhereInput;
};


export type MutationUpdateManyUsersArgs = {
  data: UpdateUserInput;
  where: UserWhereInput;
};


export type MutationUpdatePermissionArgs = {
  data: UpdatePermissionInput;
  where: PermissionWhereUniqueInput;
};


export type MutationUpdateRoleArgs = {
  data: UpdateRoleInput;
  where: RoleWhereUniqueInput;
};


export type MutationUpdateUserArgs = {
  data: UpdateUserInput;
  where: UserWhereUniqueInput;
};


export type MutationUpsertManyPermissionsArgs = {
  data: Array<CreatePermissionInput>;
};


export type MutationUpsertManyRolesArgs = {
  data: Array<CreateRoleInput>;
};


export type MutationUpsertManyUsersArgs = {
  data: Array<CreateUserInput>;
};


export type MutationUpsertPermissionArgs = {
  data: CreatePermissionInput;
};


export type MutationUpsertRoleArgs = {
  data: CreateRoleInput;
};


export type MutationUpsertUserArgs = {
  data: CreateUserInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Permission = Node & {
  __typename?: 'Permission';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  createdBy?: Maybe<User>;
  entity: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  operation: Scalars['String']['output'];
  role?: Maybe<Role>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  updatedBy?: Maybe<User>;
};

/** A connection to a list of items. */
export type PermissionConnection = {
  __typename?: 'PermissionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PermissionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PermissionEdge = {
  __typename?: 'PermissionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Permission>;
};

/** Ordering options for Permission connections */
export type PermissionOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Permissions. */
  field: PermissionOrderField;
};

/** Properties by which Permission connections can be ordered. */
export enum PermissionOrderField {
  Entity = 'entity',
  Id = 'id',
  Operation = 'operation'
}

/**
 * PermissionWhereInput is used for filtering Permission objects.
 * Input was generated by ent.
 */
export type PermissionWhereInput = {
  and?: InputMaybe<Array<PermissionWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtGT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtGTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtLTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** entity field predicates */
  entity?: InputMaybe<Scalars['String']['input']>;
  entityContains?: InputMaybe<Scalars['String']['input']>;
  entityContainsFold?: InputMaybe<Scalars['String']['input']>;
  entityEqualFold?: InputMaybe<Scalars['String']['input']>;
  entityGT?: InputMaybe<Scalars['String']['input']>;
  entityGTE?: InputMaybe<Scalars['String']['input']>;
  entityHasPrefix?: InputMaybe<Scalars['String']['input']>;
  entityHasSuffix?: InputMaybe<Scalars['String']['input']>;
  entityIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entityLT?: InputMaybe<Scalars['String']['input']>;
  entityLTE?: InputMaybe<Scalars['String']['input']>;
  entityNEQ?: InputMaybe<Scalars['String']['input']>;
  entityNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_by edge predicates */
  hasCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** role edge predicates */
  hasRole?: InputMaybe<Scalars['Boolean']['input']>;
  hasRoleWith?: InputMaybe<Array<RoleWhereInput>>;
  /** updated_by edge predicates */
  hasUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasUpdatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PermissionWhereInput>;
  /** operation field predicates */
  operation?: InputMaybe<Scalars['String']['input']>;
  operationContains?: InputMaybe<Scalars['String']['input']>;
  operationContainsFold?: InputMaybe<Scalars['String']['input']>;
  operationEqualFold?: InputMaybe<Scalars['String']['input']>;
  operationGT?: InputMaybe<Scalars['String']['input']>;
  operationGTE?: InputMaybe<Scalars['String']['input']>;
  operationHasPrefix?: InputMaybe<Scalars['String']['input']>;
  operationHasSuffix?: InputMaybe<Scalars['String']['input']>;
  operationIn?: InputMaybe<Array<Scalars['String']['input']>>;
  operationLT?: InputMaybe<Scalars['String']['input']>;
  operationLTE?: InputMaybe<Scalars['String']['input']>;
  operationNEQ?: InputMaybe<Scalars['String']['input']>;
  operationNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  or?: InputMaybe<Array<PermissionWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtGT?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PermissionWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type Query = {
  __typename?: 'Query';
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  permissions?: Maybe<Array<Permission>>;
  permissionsConnection: PermissionConnection;
  roles?: Maybe<Array<Role>>;
  rolesConnection: RoleConnection;
  users?: Maybe<Array<User>>;
  usersConnection: UserConnection;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryPermissionsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PermissionOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PermissionWhereInput>;
};


export type QueryPermissionsConnectionArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PermissionOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PermissionWhereInput>;
};


export type QueryRolesArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RoleOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RoleWhereInput>;
};


export type QueryRolesConnectionArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RoleOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RoleWhereInput>;
};


export type QueryUsersArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryUsersConnectionArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};

export type Role = Node & {
  __typename?: 'Role';
  createdAt?: Maybe<Scalars['Time']['output']>;
  createdBy?: Maybe<User>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Time']['output']>;
  updatedBy?: Maybe<User>;
};

/** A connection to a list of items. */
export type RoleConnection = {
  __typename?: 'RoleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RoleEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RoleEdge = {
  __typename?: 'RoleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Role>;
};

/** Ordering options for Role connections */
export type RoleOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Roles. */
  field: RoleOrderField;
};

/** Properties by which Role connections can be ordered. */
export enum RoleOrderField {
  CreatedAt = 'createdAt',
  Id = 'id',
  Name = 'name',
  UpdatedAt = 'updatedAt'
}

/**
 * RoleWhereInput is used for filtering Role objects.
 * Input was generated by ent.
 */
export type RoleWhereInput = {
  and?: InputMaybe<Array<RoleWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_by edge predicates */
  hasCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** updated_by edge predicates */
  hasUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasUpdatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<RoleWhereInput>;
  or?: InputMaybe<Array<RoleWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RoleWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdatePermissionInput is used for update Permission object.
 * Input was generated by ent.
 */
export type UpdatePermissionInput = {
  clearCreatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearRole?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdBy?: InputMaybe<CreateOneUserInput>;
  createdByID?: InputMaybe<Scalars['ID']['input']>;
  entity?: InputMaybe<Scalars['String']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<CreateOneRoleInput>;
  roleID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
  updatedByID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateRoleInput is used for update Role object.
 * Input was generated by ent.
 */
export type UpdateRoleInput = {
  createdBy?: InputMaybe<CreateOneUserInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissions?: InputMaybe<CreateManyPermissionInput>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
  userRoles?: InputMaybe<CreateManyUserInput>;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addRoleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearDefaultRole?: InputMaybe<Scalars['Boolean']['input']>;
  clearName?: InputMaybe<Scalars['Boolean']['input']>;
  clearRoles?: InputMaybe<Scalars['Boolean']['input']>;
  createdBy?: InputMaybe<CreateOneUserInput>;
  defaultRole?: InputMaybe<CreateOneRoleInput>;
  defaultRoleID?: InputMaybe<Scalars['ID']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  refCreatedBy?: InputMaybe<CreateManyUserInput>;
  refUpdatedBy?: InputMaybe<CreateManyUserInput>;
  removeRoleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  roles?: InputMaybe<CreateManyRoleInput>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
};

export type User = Node & {
  __typename?: 'User';
  createdAt?: Maybe<Scalars['Time']['output']>;
  createdBy?: Maybe<User>;
  defaultRole?: Maybe<Role>;
  email: Scalars['String']['output'];
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  name?: Maybe<Scalars['String']['output']>;
  password: Scalars['String']['output'];
  roles?: Maybe<Array<Role>>;
  updatedAt?: Maybe<Scalars['Time']['output']>;
  updatedBy?: Maybe<User>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
};

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  CreatedAt = 'createdAt',
  Email = 'email',
  FirstName = 'firstName',
  Id = 'id',
  LastName = 'lastName',
  Name = 'name',
  UpdatedAt = 'updatedAt'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** first_name field predicates */
  firstName?: InputMaybe<Scalars['String']['input']>;
  firstNameContains?: InputMaybe<Scalars['String']['input']>;
  firstNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  firstNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  firstNameGT?: InputMaybe<Scalars['String']['input']>;
  firstNameGTE?: InputMaybe<Scalars['String']['input']>;
  firstNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  firstNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  firstNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  firstNameLT?: InputMaybe<Scalars['String']['input']>;
  firstNameLTE?: InputMaybe<Scalars['String']['input']>;
  firstNameNEQ?: InputMaybe<Scalars['String']['input']>;
  firstNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_by edge predicates */
  hasCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** default_role edge predicates */
  hasDefaultRole?: InputMaybe<Scalars['Boolean']['input']>;
  hasDefaultRoleWith?: InputMaybe<Array<RoleWhereInput>>;
  /** roles edge predicates */
  hasRoles?: InputMaybe<Scalars['Boolean']['input']>;
  hasRolesWith?: InputMaybe<Array<RoleWhereInput>>;
  /** updated_by edge predicates */
  hasUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasUpdatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_name field predicates */
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastNameContains?: InputMaybe<Scalars['String']['input']>;
  lastNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  lastNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  lastNameGT?: InputMaybe<Scalars['String']['input']>;
  lastNameGTE?: InputMaybe<Scalars['String']['input']>;
  lastNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  lastNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  lastNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  lastNameLT?: InputMaybe<Scalars['String']['input']>;
  lastNameLTE?: InputMaybe<Scalars['String']['input']>;
  lastNameNEQ?: InputMaybe<Scalars['String']['input']>;
  lastNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** password field predicates */
  password?: InputMaybe<Scalars['String']['input']>;
  passwordContains?: InputMaybe<Scalars['String']['input']>;
  passwordContainsFold?: InputMaybe<Scalars['String']['input']>;
  passwordEqualFold?: InputMaybe<Scalars['String']['input']>;
  passwordGT?: InputMaybe<Scalars['String']['input']>;
  passwordGTE?: InputMaybe<Scalars['String']['input']>;
  passwordHasPrefix?: InputMaybe<Scalars['String']['input']>;
  passwordHasSuffix?: InputMaybe<Scalars['String']['input']>;
  passwordIn?: InputMaybe<Array<Scalars['String']['input']>>;
  passwordLT?: InputMaybe<Scalars['String']['input']>;
  passwordLTE?: InputMaybe<Scalars['String']['input']>;
  passwordNEQ?: InputMaybe<Scalars['String']['input']>;
  passwordNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserWhereUniqueInput = {
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};
