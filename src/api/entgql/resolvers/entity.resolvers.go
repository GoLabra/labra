package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"sort"

	"github.com/GoLabra/labrago/src/api/cache"
	"github.com/GoLabra/labrago/src/api/entgql/entity"
	gqlgen "github.com/GoLabra/labrago/src/api/entgql/generated"
	"github.com/GoLabra/labrago/src/api/strcase"
	"github.com/GoLabra/labrago/src/api/subscription"
	"github.com/gertd/go-pluralize"
)

// RelatedEntity is the resolver for the relatedEntity field.
func (r *edgeResolver) RelatedEntity(ctx context.Context, obj *entity.Edge) (*entity.Entity, error) {
	relatedEntity, ok := cache.Entity.Get(strcase.NodeNameToGraphqlName(obj.Type))
	if !ok {
		return nil, fmt.Errorf("related entity %s not found", strcase.NodeNameToGraphqlName(obj.Type))
	}
	return &relatedEntity, nil
}

// Df is the resolver for the df field.
func (r *entityResolver) Df(ctx context.Context, obj *entity.Entity) (string, error) {
	return obj.Caption + "Andrei cel tare" + obj.Name, nil
}

// PluralName is the resolver for the pluralName field.
func (r *entityResolver) PluralName(ctx context.Context, obj *entity.Entity) (string, error) {
	var pluralizeClient = pluralize.NewClient()
	return pluralizeClient.Plural(obj.Name), nil
}

// DisplayField is the resolver for the displayField field.
func (r *entityResolver) DisplayField(ctx context.Context, obj *entity.Entity) (*entity.Field, error) {
	var fields, ok = cache.Field.Get(obj.Name)

	if !ok {
		return &entity.Field{
			Name: obj.DisplayFieldName,
		}, nil
	}

	for _, field := range fields {
		if field.Name == obj.DisplayFieldName {
			return &field, nil
		}
	}

	return &entity.Field{
		Name: obj.DisplayFieldName,
	}, nil
}

// Fields is the resolver for the fields field.
func (r *entityResolver) Fields(ctx context.Context, obj *entity.Entity) ([]*entity.Field, error) {
	fields, ok := cache.Field.Get(obj.Name)
	if !ok {
		return nil, nil
	}

	var result = make([]*entity.Field, len(fields))

	for index := range fields {
		result[index] = &fields[index]
	}

	return result, nil
}

// Edges is the resolver for the edges field.
func (r *entityResolver) Edges(ctx context.Context, obj *entity.Entity) ([]*entity.Edge, error) {
	edges, ok := cache.Edge.Get(obj.Name)
	if !ok {
		return nil, nil
	}

	var result = make([]*entity.Edge, len(edges))

	for index := range edges {
		result[index] = &edges[index]
	}

	return result, nil
}

// CreateEntity is the resolver for the createEntity field.
func (r *mutationResolver) CreateEntity(ctx context.Context, data entity.CreateEntityInput) (*entity.Entity, error) {
	return r.Service.Entity.CreateEntity(ctx, data)
}

// UpdateEntity is the resolver for the updateEntity field.
func (r *mutationResolver) UpdateEntity(ctx context.Context, where entity.EntityWhereUniqueInput, data entity.UpdateEntityInput) (*entity.Entity, error) {
	return r.Service.Entity.UpdateEntity(ctx, where, data)
}

// DeleteEntity is the resolver for the deleteEntity field.
func (r *mutationResolver) DeleteEntity(ctx context.Context, where entity.EntityWhereUniqueInput) (*entity.Entity, error) {
	return r.Service.Entity.DeleteEntity(ctx, where)
}

// Entities is the resolver for the entities field.
func (r *queryResolver) Entities(ctx context.Context) ([]*entity.Entity, error) {
	entities := cache.Entity.GetAll()

	sort.Slice(entities, func(i, j int) bool {
		return entities[i].Caption < entities[j].Caption
	})

	var result = make([]*entity.Entity, len(entities))

	for index := range entities {
		result[index] = &entities[index]
	}

	return result, nil
}

// Entity is the resolver for the entity field.
func (r *queryResolver) Entity(ctx context.Context, where *entity.EntityWhereUniqueInput) (*entity.Entity, error) {
	entity, ok := cache.Entity.Get(*where.Name)
	if !ok {
		return nil, nil
	}
	return &entity, nil
}

// Fields is the resolver for the fields field.
func (r *queryResolver) Fields(ctx context.Context) ([]*entity.Field, error) {
	fieldBatches := cache.Field.GetAll()
	fields := []entity.Field{}
	for _, fieldBatch := range fieldBatches {
		fields = append(fields, fieldBatch...)
	}

	var result = make([]*entity.Field, len(fields))

	for index := range fields {
		result[index] = &fields[index]
	}

	return result, nil
}

// AppStatus is the resolver for the appStatus field.
func (r *subscriptionResolver) AppStatus(ctx context.Context) (<-chan subscription.AppStatus, error) {
	c := make(chan subscription.AppStatus)
	r.SubscriptionClient.AppStatusSubscribers = append(r.SubscriptionClient.AppStatusSubscribers, subscription.AppStatusSubscriber{
		Ctx:  ctx,
		Chan: c,
	})
	return c, nil
}

// Entities is the resolver for the entities field.
func (r *subscriptionResolver) Entities(ctx context.Context) (<-chan []*entity.Entity, error) {
	c := make(chan []*entity.Entity)
	r.SubscriptionClient.EntitySubscribers = append(r.SubscriptionClient.EntitySubscribers, subscription.EntitySubscriber{
		Ctx:  ctx,
		Chan: c,
	})
	return c, nil
}

// Edge returns gqlgen.EdgeResolver implementation.
func (r *Resolver) Edge() gqlgen.EdgeResolver { return &edgeResolver{r} }

// Entity returns gqlgen.EntityResolver implementation.
func (r *Resolver) Entity() gqlgen.EntityResolver { return &entityResolver{r} }

// Mutation returns gqlgen.MutationResolver implementation.
func (r *Resolver) Mutation() gqlgen.MutationResolver { return &mutationResolver{r} }

// Query returns gqlgen.QueryResolver implementation.
func (r *Resolver) Query() gqlgen.QueryResolver { return &queryResolver{r} }

// Subscription returns gqlgen.SubscriptionResolver implementation.
func (r *Resolver) Subscription() gqlgen.SubscriptionResolver { return &subscriptionResolver{r} }

type edgeResolver struct{ *Resolver }
type entityResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
